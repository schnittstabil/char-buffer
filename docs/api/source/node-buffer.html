<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">&#39;use strict&#39;;
var Buffer = require(&#39;buffer&#39;).Buffer;
var AbstractCharBuffer = require(&#39;./abstract-char-buffer&#39;);

<span id='CharBuffer-NodeBuffer'>/**
</span>	* @class CharBuffer.NodeBuffer
	* @extends CharBuffer.AbstractCharBuffer
	*
	* {@link CharBuffer.AbstractCharBuffer} implementation using a [Node.js Buffer][1].
	*
	* [1]: http://nodejs.org/api/buffer.html
	*/

<span id='CharBuffer-NodeBuffer-method-constructor'>/**
</span>	* @method constructor
	*
	* Constructs a NodeBuffer representing an empty {@link String}.
	* @param {Number} initCapacity The initial capacity (i.e. the expected
	*     {@link String#length length} of the {@link String} represented by this
	*     buffer).
	*/
function NodeBuffer(initCapacity) {
	if (!(this instanceof NodeBuffer)) {
		return new NodeBuffer(initCapacity);
	}
	AbstractCharBuffer.call(this);
	initCapacity = initCapacity || 16;
	this._buffer = new Buffer(initCapacity * 2);
}

NodeBuffer.prototype = new AbstractCharBuffer();

NodeBuffer.prototype.constructor = NodeBuffer;

/* istanbul ignore if: IE-fix */
if (!NodeBuffer.name) {
	NodeBuffer.name = &#39;NodeBuffer&#39;;
}

<span id='CharBuffer-NodeBuffer-method-_ensureCapacity'>/**
</span>	* @method
	* @protected
	*
	* Ensures a minimum capacity.
	* @param {Number} minCapacity The minimum capacity (i.e. the expected
	*     {@link String#length length} of the {@link String} this buffer may
	*     represent).
	*/
NodeBuffer.prototype._ensureCapacity = function (minCapacity) {
	if (this._buffer.length &lt; minCapacity * 2) {
		if (minCapacity &lt; this._buffer.length) {
			minCapacity = this._buffer.length; // i.e. double the capacity (!)
		}
		var buffer = new Buffer(minCapacity * 2);
		this._buffer.copy(buffer);
		this._buffer = buffer;
	}
};

<span id='CharBuffer-NodeBuffer-method-write'>/**
</span>	* @method
	* Write a charCode to the buffer using
	* [Buffer.writeUInt16LE(charCode, ...)][1].
	*
	* [1]: http://nodejs.org/api/buffer.html#buffer_buf_writeuint16le_value_offset_noassert
	* @param {Number} charCode The charCode to append.
	* @param {Number} offset The zero based offset to write at.
	*/
NodeBuffer.prototype.write = function (charCode, offset) {
	if (typeof offset === &#39;undefined&#39;) {
		offset = this.length;
	}
	this._ensureCapacity(offset + 1);
	this._buffer.writeUInt16LE(charCode, offset * 2);
	this.length = offset + 1 &gt; this.length ? offset + 1 : this.length;
	return this;
};

<span id='CharBuffer-NodeBuffer-method-append'>/** @method */
</span>NodeBuffer.prototype.append = NodeBuffer.prototype.write;

<span id='CharBuffer-NodeBuffer-method-read'>/** @method */
</span>NodeBuffer.prototype.read = function (offset) {
	return this._buffer.readUInt16LE(offset * 2);
};

<span id='CharBuffer-NodeBuffer-method-charCodeAt'>/** @method */
</span>NodeBuffer.prototype.charCodeAt = NodeBuffer.prototype.read;

<span id='CharBuffer-NodeBuffer-method-charAt'>/** @method */
</span>NodeBuffer.prototype.charAt = function (offset) {
	return String.fromCharCode(this.read(offset));
};

<span id='CharBuffer-NodeBuffer-method-toString'>/**
</span>	* @method
	* Returns the {@link String} represented by this buffer using
	* [Buffer.toString(&#39;utf16le&#39;, ...)][1].
	*
	* [1]: http://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end
	*
	* @return {String} The string.
	*/
NodeBuffer.prototype.toString = function () {
	return this._buffer.toString(&#39;utf16le&#39;, 0, this.length * 2);
};

<span id='CharBuffer-NodeBuffer-static-property-isSupported'>/** @static @property */
</span>Object.defineProperty(NodeBuffer, &#39;isSupported&#39;, {
	get: function () {
		try {
			var buffer = new Buffer(&#39;A&#39;, &#39;utf16le&#39;);
			return buffer.readUInt16LE(0) === 65;
		} catch (err) {
			/* istanbul ignore next */
			return false;
		}
	}
});

<span id='CharBuffer-NodeBuffer-static-method-fromString'>/** @static @method */
</span>NodeBuffer.fromString = AbstractCharBuffer.fromStringConstr(NodeBuffer);

module.exports = NodeBuffer;
</pre>
</body>
</html>
