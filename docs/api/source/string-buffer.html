<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">&#39;use strict&#39;;
var AbstractCharBuffer = require(&#39;./abstract-char-buffer&#39;);

<span id='CharBuffer-StringBuffer'>/**
</span>	* @class CharBuffer.StringBuffer
	* @extends CharBuffer.AbstractCharBuffer
	*
	* {@link CharBuffer.AbstractCharBuffer} implementation using a single {@link String}.
	*/

<span id='CharBuffer-StringBuffer-method-constructor'>/**
</span>	* @method constructor
	*
	* Constructs a StringBuffer representing an empty string.
	*/
function StringBuffer() {
	if (!(this instanceof StringBuffer)) {
		return new StringBuffer();
	}
	AbstractCharBuffer.call(this);
	this._buffer = &#39;&#39;;
}

StringBuffer.prototype = new AbstractCharBuffer();

StringBuffer.prototype.constructor = StringBuffer;

/* istanbul ignore if: IE-fix */
if (!StringBuffer.name) {
	StringBuffer.name = &#39;StringBuffer&#39;;
}

<span id='CharBuffer-StringBuffer-method-write'>/**
</span>	* @method
	* Write a charCode to the buffer using
	* {@link String#fromCharCode} and {@link String#concat +}.
	*
	* @param {Number} charCode The charCode to append.
	* @param {Number} offset The zero based offset to write at.
	*/
StringBuffer.prototype.write = function (charCode, offset) {
	if (typeof offset === &#39;undefined&#39; || offset === this.length) {
		return this.append(charCode);
	}
	var pre = this._buffer.slice(0, offset);
	var post = this._buffer.slice(offset + 1);
	this._buffer = pre + String.fromCharCode(charCode) + post;
	this.length = this._buffer.length;
	return this;
};

<span id='CharBuffer-StringBuffer-method-append'>/** @method */
</span>StringBuffer.prototype.append = function (charCode) {
	this._buffer += String.fromCharCode(charCode);
	this.length = this._buffer.length;
	return this;
};

<span id='CharBuffer-StringBuffer-method-charCodeAt'>/** @method */
</span>StringBuffer.prototype.charCodeAt = function (offset) {
	return this._buffer.charCodeAt(offset);
};

<span id='CharBuffer-StringBuffer-method-charAt'>/** @method */
</span>StringBuffer.prototype.charAt = function (offset) {
	return this._buffer.charAt(offset);
};

<span id='CharBuffer-StringBuffer-method-read'>/** @method */
</span>StringBuffer.prototype.read = StringBuffer.prototype.charCodeAt;

<span id='CharBuffer-StringBuffer-method-setLength'>/** @method */
</span>StringBuffer.prototype.setLength = function (newLength) {
	AbstractCharBuffer.prototype.setLength.call(this, newLength);
	this._buffer = this._buffer.slice(0, this.length);
	return this;
};

<span id='CharBuffer-StringBuffer-method-toString'>/**
</span>	* @method
	* Returns the internal {@link String}.
	* @return {String} The string.
	*/
StringBuffer.prototype.toString = function () {
	return this._buffer;
};

<span id='CharBuffer-StringBuffer-static-property-isSupported'>/** @static @property */
</span>StringBuffer.isSupported = true;

<span id='CharBuffer-StringBuffer-static-method-fromString'>/** @static @method */
</span>StringBuffer.fromString = function (string, transform) {
	var output = new StringBuffer();
	var len = string.length;
	var buffer;
	var i;

	if (transform) {
		buffer = &#39;&#39;;
		for (i = 0; i &lt; len; i++) {
			buffer += String.fromCharCode(transform.call(transform, string.charCodeAt(i), i));
		}
	} else {
		// JavaScript strings are immutable
		buffer = string;
	}

	output._buffer = buffer;
	output.length = len;
	return output;
};

module.exports = StringBuffer;
</pre>
</body>
</html>
